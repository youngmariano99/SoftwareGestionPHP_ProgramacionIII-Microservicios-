¬°Por supuesto! Ha sido un proyecto excelente y me parece una idea fant√°stica capturar todo en una gu√≠a.

Como no puedo generar un archivo PDF directamente, he escrito el resumen completo en **formato Markdown** (texto plano).

Para **convertirlo en PDF**, te recomiendo dos opciones f√°ciles:
1.  **Si usas VSCode:** Pega este texto en un archivo nuevo llamado `Guia_Proyecto.md`. Haz clic derecho en la pesta√±a del archivo y busca una opci√≥n como "Exportar a PDF" (es posible que necesites una extensi√≥n gratuita como "Markdown PDF").
2.  **Opci√≥n Online:** Simplemente copia todo el texto de abajo y p√©galo en un conversor online (busca "Markdown to PDF converter" en Google).

---

# Gu√≠a Definitiva del Proyecto: De Monolito PHP a Microservicios con Docker

Este documento es un resumen completo de la transformaci√≥n de una aplicaci√≥n PHP monol√≠tica a una arquitectura de microservicios moderna, empaquetada con Docker y Docker Compose.

---

## 1. El Punto de Partida: El Monolito üß±

Comenzamos con una aplicaci√≥n PHP tradicional, com√∫nmente llamada **"Monolito"**.

### Caracter√≠sticas Principales:
* **Todo en uno:** El c√≥digo del frontend (vistas HTML/PHP) y del backend (l√≥gica de negocio, conexi√≥n a BD) residen en la misma base de c√≥digo y se ejecutan como un solo programa.
* **Acoplamiento Fuerte:** El frontend llamaba a la l√≥gica del backend usando `include` o `require` de PHP, creando una dependencia directa.
* **Base de Datos √önica:** Toda la aplicaci√≥n (usuarios, productos, ventas) le√≠a y escrib√≠a sobre una √∫nica base de datos.
* **Gesti√≥n de Estado:** La autenticaci√≥n se manejaba con **`$_SESSION`** de PHP, atando al usuario a un servidor espec√≠fico.

---

## 2. La Transformaci√≥n: Arquitectura de Microservicios üß©

El objetivo fue "desacoplar" la aplicaci√≥n dividi√©ndola en servicios independientes.

### Caracter√≠sticas Principales:
* **Separaci√≥n de Responsabilidades:** Cada servicio tiene una √∫nica funci√≥n (gestionar usuarios, gestionar productos, etc.) y es due√±o de sus propios datos.
* **Acoplamiento D√©bil:** Los servicios se comunican entre s√≠ a trav√©s de la red usando **peticiones HTTP** (APIs RESTful), no con `include`.
* **Cliente y Servidor Separados:** El `frontend` (cliente) ahora es una aplicaci√≥n de JavaScript que "consume" a los servicios (servidores).
* **Gesti√≥n de Estado "sin estado":** Reemplazamos las `$_SESSION` por **Tokens JWT** (JSON Web Tokens). El frontend guarda este "carnet" y lo presenta en cada petici√≥n para autenticarse.

---

## 3. Los 5 Componentes de la Nueva Arquitectura

Dividimos el proyecto en 5 carpetas/servicios independientes:

### 1. `frontend/` (La Cara de la Tienda)
* **Puerto:** `3000`
* **Rol:** Servir el HTML y el JavaScript al navegador del usuario. Es el √∫nico servicio con el que el usuario interact√∫a directamente.
* **Tecnolog√≠as:**
    * `JavaScript` (puro)
    * `fetch()`: Para realizar peticiones HTTP as√≠ncronas (el "mensajero").
    * `localStorage`: Para almacenar el token JWT en el navegador.
* **L√≥gica Clave:**
    * Env√≠a el email/pass al Gateway.
    * Recibe un token y lo guarda en `localStorage`.
    * En las siguientes peticiones, lee el token del `localStorage` y lo a√±ade al encabezado `Authorization`.
    * Muestra un panel u otro (`admin` o `vendedor`) basado en el rol decodificado del token.

### 2. `api_gateway/` (El Peaje y Recepcionista)
* **Puerto:** `8000`
* **Rol:** El **√∫nico punto de entrada** para el frontend. Protege y redirige todas las peticiones.
* **Tecnolog√≠as:**
    * `Slim`: Para enrutar las peticiones entrantes.
    * `Guzzle`: Para "reenviar" la petici√≥n al microservicio interno correcto.
    * `Firebase/php-jwt`: Para **validar** los tokens JWT.
* **L√≥gica Clave:**
    * **CORS:** A√±ade encabezados `Access-Control-Allow-Origin` para permitir peticiones desde `localhost:3000`.
    * **Ruta de "permiso" `OPTIONS`:** Responde `200 OK` a las peticiones `OPTIONS` del navegador.
    * **Guardia de Seguridad:** En todas las rutas (excepto `/login` y `/registro`), verifica el token (`Authorization: Bearer ...`). Si es inv√°lido, devuelve un error `401`.
    * **Control de Roles (RBAC):** Lee el rol *dentro* del token (ej. `administrador`) y decide si puede acceder a la ruta (ej. `/empleados`). Si no, devuelve `403`.
    * **Proxy/Redirecci√≥n:** Si todo es v√°lido, usa Guzzle para llamar al servicio interno (ej. `http://usuarios/empleados`).

### 3. `servicio_usuarios/` (El Guardia de Identidad)
* **Puerto:** (Interno, solo accesible por el Gateway)
* **Tecnolog√≠as:**
    * `Slim`: Para definir los endpoints `/login` y `/registro`.
    * `vlucas/phpdotenv`: Para cargar secretos y credenciales de BD desde un archivo `.env`.
    * `PDO`: Para conectarse a la base de datos MySQL.
    * `Firebase/php-jwt`: Para **crear** los tokens JWT.
* **L√≥gica Clave:**
    * **`/registro`:** Recibe `POST`, hashea la contrase√±a con `password_hash()` y la guarda en la BD.
    * **`/login`:** Recibe `POST`, busca el usuario en la BD por email, y comprueba la contrase√±a usando `password_verify()`. Si es exitoso, crea un token JWT con los datos del usuario (ID, nombre, rol) dentro.

### 4. `servicio_productos/` (El Encargado de Inventario)
* **Puerto:** (Interno)
* **Tecnolog√≠as:**
    * `Slim`: Para definir los endpoints CRUD (ej. `GET /productos`, `PUT /productos/:id/stock`).
    * `mongodb/mongodb`: El driver oficial de MongoDB para PHP.
* **L√≥gica Clave:**
    * Es el **√∫nico** servicio que sabe c√≥mo conectarse a la base de datos de productos (MongoDB Atlas).
    * Provee m√©todos para que otros servicios le pregunten por el stock o lo actualicen.

### 5. `servicio_ventas/` (El Orquestador de L√≥gica)
* **Puerto:** (Interno)
* **Tecnolog√≠as:**
    * `Slim`: Para definir el endpoint `POST /ventas`.
    * `Guzzle`: Para comunicarse con el `servicio_productos`.
* **L√≥gica Clave:**
    * Recibe la petici√≥n de venta.
    * **Comunicaci√≥n Inter-Servicio:** Antes de confirmar la venta, usa Guzzle para llamar al `servicio_productos` (`http://productos/productos/:id`) y verificar el stock.
    * Si hay stock, usa Guzzle otra vez para llamar a `http://productos/productos/:id/stock` (con `PUT`) y descontar la cantidad vendida.

---

## 4. El Flujo de Datos: Una Petici√≥n de Ejemplo

Este es el flujo completo de una petici√≥n de un usuario para registrar una venta:

1.  **Frontend (JS):** El usuario hace clic en "Vender".
2.  **`fetch()`:** JavaScript crea una petici√≥n `POST` para `http://localhost:8000/ventas`.
3.  **Token:** JS toma el token de `localStorage` y lo a√±ade al encabezado: `Authorization: Bearer <token>`.
4.  **`api_gateway` (Puerto 8000):**
    * Recibe la petici√≥n.
    * Valida el token JWT. Es v√°lido.
    * Lee el rol "vendedor". Tiene permiso para `/ventas`.
    * Usa **Guzzle** para reenviar la petici√≥n a la direcci√≥n interna: `http://ventas/ventas`.
5.  **`servicio_ventas` (Interno):**
    * Recibe la petici√≥n de venta.
    * Inicia un `foreach` por los productos.
    * Usa **Guzzle** para llamar al servicio de productos: `GET http://productos/productos/123`.
6.  **`servicio_productos` (Interno):**
    * Recibe la petici√≥n de `servicio_ventas`.
    * Busca el producto `123` en MongoDB.
    * Devuelve el JSON del producto: `{"id": 123, "stock": 50}`.
7.  **`servicio_ventas` (Interno):**
    * Recibe la respuesta de Guzzle.
    * Comprueba que `50` (stock) es mayor que la cantidad a vender.
    * Usa **Guzzle** otra vez: `PUT http://productos/productos/123/stock` con el JSON `{"stock": 49}`.
8.  **`servicio_productos` (Interno):**
    * Recibe la petici√≥n `PUT`.
    * Actualiza el stock del producto `123` a `49` en MongoDB.
    * Devuelve `{"status": "success"}`.
9.  **`servicio_ventas` (Interno):**
    * Recibe el "success". Termina su l√≥gica.
    * Devuelve la respuesta final de la venta (ej. `{"status": "Venta registrada"}`) al `api_gateway`.
10. **`api_gateway` (Puerto 8000):**
    * Recibe la respuesta de `servicio_ventas`.
    * La reenv√≠a id√©ntica al `frontend`.
11. **Frontend (JS):**
    * El `fetch` original se completa.
    * Entra en el `.then(data => ...)` final.
    * Muestra `data.status` ("Venta registrada") al usuario.

---

## 5. El Despliegue: Docker y Docker Compose üê≥

Para evitar tener que correr 5 terminales con `php -S`, usamos Docker para orquestar toda la aplicaci√≥n.

### Glosario de Conceptos de Docker

* **`Dockerfile` (La Receta üìú):** Un archivo de texto en cada servicio que define los pasos para construir su "caja". Le dice qu√© S.O. usar (`FROM php:8.3-apache`), qu√© extensiones instalar (`RUN docker-php-ext-install pdo_mysql`) y qu√© c√≥digo copiar (`COPY . /var/www/html`).
* **`Imagen` (El Plano üñºÔ∏è):** El resultado de `docker build`. Es una plantilla autocontenida (un "mini-servidor") que tiene PHP, Apache y tu c√≥digo listos para ser ejecutados.
* **`Contenedor` (La Caja en Ejecuci√≥n üì¶):** Una instancia viva de una Imagen. Es la "caja" que est√° corriendo tu servicio.
* **`docker-compose.yml` (El Director de Orquesta üéº):** El archivo YAML principal que le dice a Docker Compose:
    * Qu√© servicios construir (frontend, gateway, usuarios, etc.).
    * D√≥nde encontrar su `Dockerfile` (ej. `build: ./frontend`).
    * Qu√© puertos abrir al exterior (ej. `ports: - "3000:80"`).
* **Red de Docker (El Barrio Privado üè°):** Cuando se levanta con `docker compose`, todos los contenedores se conectan a una red virtual. Dentro de esta red, pueden llamarse unos a otros usando sus **nombres de servicio** (ej. `http://usuarios`, `http://productos`) en lugar de `localhost` y puertos.
* **Vol√∫menes (El Portal üîÆ):**
    * La l√≠nea `volumes: - ./frontend:/var/www/html:Z` en el `docker-compose.yml`.
    * Crea un "espejo" entre la carpeta de tu PC (ej. `./frontend`) y la carpeta *dentro* del contenedor (`/var/www/html`).
    * **Esto te permite editar c√≥digo en tu PC y ver los cambios al instante en el navegador sin tener que reconstruir la imagen.**

### Comandos Clave

* `docker compose up --build`: El comando √∫nico. Construye todas las im√°genes (si cambiaron) y levanta todos los contenedores.
* `docker compose down`: Detiene y elimina todos los contenedores definidos en el `docker-compose.yml`.
* `docker ps`: Lista los contenedores que est√°n actualmente en ejecuci√≥n.
* `docker stop <nombre_contenedor>`: Detiene un contenedor espec√≠fico (ej. `docker stop srv-usuarios`).
* `docker rm <nombre_contenedor>`: Elimina un contenedor detenido.
* `docker build -t <nombre-imagen> .`: (Lo que us√°bamos al principio) Construye una imagen manualmente desde un `Dockerfile`.

---

## 6. Lecciones Aprendidas (Resoluci√≥n de Errores) üí°

Durante el proyecto, resolvimos problemas del mundo real:

* **Error de CORS (`Access-Control-Allow-Origin...`)**
    * **Causa:** El navegador (`localhost:3000`) intentaba llamar al `api_gateway` (`localhost:8000`). Al ser puertos diferentes, el navegador lo bloqueaba por seguridad.
    * **Soluci√≥n:** A√±adimos un "Middleware" en el `api_gateway` (Slim) que a√±ade los encabezados `Access-Control-Allow-Origin: 'http://localhost:3000'` a cada respuesta, d√°ndole permiso expl√≠cito al navegador.

* **Error de Login (`Credenciales incorrectas`)**
    * **Causa:** Hab√≠amos guardado la contrase√±a en la BD como texto plano (`123456`), pero el c√≥digo intentaba verificarla con `password_verify()`, que espera un **HASH**.
    * **Soluci√≥n:** Usamos el endpoint `/registro` (que usa `password_hash()`) para crear un usuario correctamente. La contrase√±a en la BD ahora se ve como `$2y$10$...`.

* **Error de Guzzle en `servicio_ventas` (`Connection refused`)**
    * **Causa:** El `servicio_ventas` (dentro de un contenedor) intentaba llamar a `http://localhost:8000/productos`.
    * **Soluci√≥n:** `localhost` dentro de un contenedor es *√©l mismo*. La direcci√≥n correcta para la comunicaci√≥n interna de Docker es el **nombre del servicio**: `http://productos/productos/...`.

* **Error de Docker Build (`mongodb.so: undefined symbol: SSL_...`)**
    * **Causa:** La extensi√≥n de PHP para MongoDB (`pecl install mongodb`) necesita las librer√≠as de SSL del sistema operativo. Nuestra "receta" (`Dockerfile`) intent√≥ instalar la extensi√≥n de PHP antes que las librer√≠as del sistema.
    * **Soluci√≥n:** Modificamos el `Dockerfile` del `servicio_productos` para que primero ejecutara `RUN apt-get install -y libssl-dev` y *luego* ejecutara `RUN pecl install mongodb...`.

* **Error de Vol√∫menes (`403 Forbidden`)**
    * **Causa:** Usamos `volumes:` para ver los cambios de c√≥digo en vivo. Esto cre√≥ un "portal" a los archivos de nuestra m√°quina, que eran propiedad del usuario `mariano3128`. El Apache *dentro* del contenedor (usuario `www-data`) no ten√≠a permisos para leerlos.
    * **Soluci√≥n:** Usamos el flag `:Z` en el `docker-compose.yml` (ej. `- ./frontend:/var/www/html:Z`). Esto le indica a Docker que ajuste las "etiquetas" de seguridad de SELinux para permitir que el contenedor lea los archivos del host.
```