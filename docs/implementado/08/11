¬°Por supuesto! Ha sido un proyecto excelente y me parece una idea fant√°stica capturar todo en una gu√≠a.

Como no puedo generar un archivo PDF directamente, he escrito el resumen completo en **formato Markdown** (texto plano).

Para **convertirlo en PDF**, te recomiendo dos opciones f√°ciles:
1.  **Si usas VSCode:** Pega este texto en un archivo nuevo llamado `Guia_Proyecto.md`. Haz clic derecho en la pesta√±a del archivo y busca una opci√≥n como "Exportar a PDF" (es posible que necesites una extensi√≥n gratuita como "Markdown PDF").
2.  **Opci√≥n Online:** Simplemente copia todo el texto de abajo y p√©galo en un conversor online (busca "Markdown to PDF converter" en Google).

---

# Gu√≠a Definitiva del Proyecto: De Monolito PHP a Microservicios con Docker

Este documento es un resumen completo de la transformaci√≥n de una aplicaci√≥n PHP monol√≠tica a una arquitectura de microservicios moderna, empaquetada con Docker y Docker Compose.

---

## 1. El Punto de Partida: El Monolito üß±

Comenzamos con una aplicaci√≥n PHP tradicional, com√∫nmente llamada **"Monolito"**.

### Caracter√≠sticas Principales:
* **Todo en uno:** El c√≥digo del frontend (vistas HTML/PHP) y del backend (l√≥gica de negocio, conexi√≥n a BD) residen en la misma base de c√≥digo y se ejecutan como un solo programa.
* **Acoplamiento Fuerte:** El frontend llamaba a la l√≥gica del backend usando `include` o `require` de PHP, creando una dependencia directa.
* **Base de Datos √önica:** Toda la aplicaci√≥n (usuarios, productos, ventas) le√≠a y escrib√≠a sobre una √∫nica base de datos.
* **Gesti√≥n de Estado:** La autenticaci√≥n se manejaba con **`$_SESSION`** de PHP, atando al usuario a un servidor espec√≠fico.

---

## 2. La Transformaci√≥n: Arquitectura de Microservicios üß©

El objetivo fue "desacoplar" la aplicaci√≥n dividi√©ndola en servicios independientes.

### Caracter√≠sticas Principales:
* **Separaci√≥n de Responsabilidades:** Cada servicio tiene una √∫nica funci√≥n (gestionar usuarios, gestionar productos, etc.) y es due√±o de sus propios datos.
* **Acoplamiento D√©bil:** Los servicios se comunican entre s√≠ a trav√©s de la red usando **peticiones HTTP** (APIs RESTful), no con `include`.
* **Cliente y Servidor Separados:** El `frontend` (cliente) ahora es una aplicaci√≥n de JavaScript que "consume" a los servicios (servidores).
* **Gesti√≥n de Estado "sin estado":** Reemplazamos las `$_SESSION` por **Tokens JWT** (JSON Web Tokens). El frontend guarda este "carnet" y lo presenta en cada petici√≥n para autenticarse.

---

## 3. Los 5 Componentes de la Nueva Arquitectura

Dividimos el proyecto en 5 carpetas/servicios independientes:

### 1. `frontend/` (La Cara de la Tienda)
* **Puerto:** `3000`
* **Rol:** Servir el HTML y el JavaScript al navegador del usuario. Es el √∫nico servicio con el que el usuario interact√∫a directamente.
* **Tecnolog√≠as:**
    * `JavaScript` (puro)
    * `fetch()`: Para realizar peticiones HTTP as√≠ncronas (el "mensajero").
    * `localStorage`: Para almacenar el token JWT en el navegador.
* **L√≥gica Clave:**
    * Env√≠a el email/pass al Gateway.
    * Recibe un token y lo guarda en `localStorage`.
    * En las siguientes peticiones, lee el token del `localStorage` y lo a√±ade al encabezado `Authorization`.
    * Muestra un panel u otro (`admin` o `vendedor`) basado en el rol decodificado del token.

### 2. `api_gateway/` (El Peaje y Recepcionista)
* **Puerto:** `8000`
* **Rol:** El **√∫nico punto de entrada** para el frontend. Protege y redirige todas las peticiones.
* **Tecnolog√≠as:**
    * `Slim`: Para enrutar las peticiones entrantes.
    * `Guzzle`: Para "reenviar" la petici√≥n al microservicio interno correcto.
    * `Firebase/php-jwt`: Para **validar** los tokens JWT.
* **L√≥gica Clave:**
    * **CORS:** A√±ade encabezados `Access-Control-Allow-Origin` para permitir peticiones desde `localhost:3000`.
    * **Ruta de "permiso" `OPTIONS`:** Responde `200 OK` a las peticiones `OPTIONS` del navegador.
    * **Guardia de Seguridad:** En todas las rutas (excepto `/login` y `/registro`), verifica el token (`Authorization: Bearer ...`). Si es inv√°lido, devuelve un error `401`.
    * **Control de Roles (RBAC):** Lee el rol *dentro* del token (ej. `administrador`) y decide si puede acceder a la ruta (ej. `/empleados`). Si no, devuelve `403`.
    * **Proxy/Redirecci√≥n:** Si todo es v√°lido, usa Guzzle para llamar al servicio interno (ej. `http://usuarios/empleados`).

### 3. `servicio_usuarios/` (El Guardia de Identidad)
* **Puerto:** (Interno, solo accesible por el Gateway)
* **Tecnolog√≠as:**
    * `Slim`: Para definir los endpoints `/login` y `/registro`.
    * `vlucas/phpdotenv`: Para cargar secretos y credenciales de BD desde un archivo `.env`.
    * `PDO`: Para conectarse a la base de datos MySQL.
    * `Firebase/php-jwt`: Para **crear** los tokens JWT.
* **L√≥gica Clave:**
    * **`/registro`:** Recibe `POST`, hashea la contrase√±a con `password_hash()` y la guarda en la BD.
    * **`/login`:** Recibe `POST`, busca el usuario en la BD por email, y comprueba la contrase√±a usando `password_verify()`. Si es exitoso, crea un token JWT con los datos del usuario (ID, nombre, rol) dentro.

### 4. `servicio_productos/` (El Encargado de Inventario)
* **Puerto:** (Interno)
* **Tecnolog√≠as:**
    * `Slim`: Para definir los endpoints CRUD (ej. `GET /productos`, `PUT /productos/:id/stock`).
    * `mongodb/mongodb`: El driver oficial de MongoDB para PHP.
* **L√≥gica Clave:**
    * Es el **√∫nico** servicio que sabe c√≥mo conectarse a la base de datos de productos (MongoDB Atlas).
    * Provee m√©todos para que otros servicios le pregunten por el stock o lo actualicen.

### 5. `servicio_ventas/` (El Orquestador de L√≥gica)
* **Puerto:** (Interno)
* **Tecnolog√≠as:**
    * `Slim`: Para definir el endpoint `POST /ventas`.
    * `Guzzle`: Para comunicarse con el `servicio_productos`.
* **L√≥gica Clave:**
    * Recibe la petici√≥n de venta.
    * **Comunicaci√≥n Inter-Servicio:** Antes de confirmar la venta, usa Guzzle para llamar al `servicio_productos` (`http://productos/productos/:id`) y verificar el stock.
    * Si hay stock, usa Guzzle otra vez para llamar a `http://productos/productos/:id/stock` (con `PUT`) y descontar la cantidad vendida.

---

## 4. El Flujo de Datos: Una Petici√≥n de Ejemplo

Este es el flujo completo de una petici√≥n de un usuario para registrar una venta:

1.  **Frontend (JS):** El usuario hace clic en "Vender".
2.  **`fetch()`:** JavaScript crea una petici√≥n `POST` para `http://localhost:8000/ventas`.
3.  **Token:** JS toma el token de `localStorage` y lo a√±ade al encabezado: `Authorization: Bearer <token>`.
4.  **`api_gateway` (Puerto 8000):**
    * Recibe la petici√≥n.
    * Valida el token JWT. Es v√°lido.
    * Lee el rol "vendedor". Tiene permiso para `/ventas`.
    * Usa **Guzzle** para reenviar la petici√≥n a la direcci√≥n interna: `http://ventas/ventas`.
5.  **`servicio_ventas` (Interno):**
    * Recibe la petici√≥n de venta.
    * Inicia un `foreach` por los productos.
    * Usa **Guzzle** para llamar al servicio de productos: `GET http://productos/productos/123`.
6.  **`servicio_productos` (Interno):**
    * Recibe la petici√≥n de `servicio_ventas`.
    * Busca el producto `123` en MongoDB.
    * Devuelve el JSON del producto: `{"id": 123, "stock": 50}`.
7.  **`servicio_ventas` (Interno):**
    * Recibe la respuesta de Guzzle.
    * Comprueba que `50` (stock) es mayor que la cantidad a vender.
    * Usa **Guzzle** otra vez: `PUT http://productos/productos/123/stock` con el JSON `{"stock": 49}`.
8.  **`servicio_productos` (Interno):**
    * Recibe la petici√≥n `PUT`.
    * Actualiza el stock del producto `123` a `49` en MongoDB.
    * Devuelve `{"status": "success"}`.
9.  **`servicio_ventas` (Interno):**
    * Recibe el "success". Termina su l√≥gica.
    * Devuelve la respuesta final de la venta (ej. `{"status": "Venta registrada"}`) al `api_gateway`.
10. **`api_gateway` (Puerto 8000):**
    * Recibe la respuesta de `servicio_ventas`.
    * La reenv√≠a id√©ntica al `frontend`.
11. **Frontend (JS):**
    * El `fetch` original se completa.
    * Entra en el `.then(data => ...)` final.
    * Muestra `data.status` ("Venta registrada") al usuario.

---

## 5. El Despliegue: Docker y Docker Compose üê≥

Para evitar tener que correr 5 terminales con `php -S`, usamos Docker para orquestar toda la aplicaci√≥n.

### Glosario de Conceptos de Docker

* **`Dockerfile` (La Receta üìú):** Un archivo de texto en cada servicio que define los pasos para construir su "caja". Le dice qu√© S.O. usar (`FROM php:8.3-apache`), qu√© extensiones instalar (`RUN docker-php-ext-install pdo_mysql`) y qu√© c√≥digo copiar (`COPY . /var/www/html`).
* **`Imagen` (El Plano üñºÔ∏è):** El resultado de `docker build`. Es una plantilla autocontenida (un "mini-servidor") que tiene PHP, Apache y tu c√≥digo listos para ser ejecutados.
* **`Contenedor` (La Caja en Ejecuci√≥n üì¶):** Una instancia viva de una Imagen. Es la "caja" que est√° corriendo tu servicio.
* **`docker-compose.yml` (El Director de Orquesta üéº):** El archivo YAML principal que le dice a Docker Compose:
    * Qu√© servicios construir (frontend, gateway, usuarios, etc.).
    * D√≥nde encontrar su `Dockerfile` (ej. `build: ./frontend`).
    * Qu√© puertos abrir al exterior (ej. `ports: - "3000:80"`).
* **Red de Docker (El Barrio Privado üè°):** Cuando se levanta con `docker compose`, todos los contenedores se conectan a una red virtual. Dentro de esta red, pueden llamarse unos a otros usando sus **nombres de servicio** (ej. `http://usuarios`, `http://productos`) en lugar de `localhost` y puertos.
* **Vol√∫menes (El Portal üîÆ):**
    * La l√≠nea `volumes: - ./frontend:/var/www/html:Z` en el `docker-compose.yml`.
    * Crea un "espejo" entre la carpeta de tu PC (ej. `./frontend`) y la carpeta *dentro* del contenedor (`/var/www/html`).
    * **Esto te permite editar c√≥digo en tu PC y ver los cambios al instante en el navegador sin tener que reconstruir la imagen.**

### Comandos Clave

* `docker compose up --build`: El comando √∫nico. Construye todas las im√°genes (si cambiaron) y levanta todos los contenedores.
* `docker compose down`: Detiene y elimina todos los contenedores definidos en el `docker-compose.yml`.
* `docker ps`: Lista los contenedores que est√°n actualmente en ejecuci√≥n.
* `docker stop <nombre_contenedor>`: Detiene un contenedor espec√≠fico (ej. `docker stop srv-usuarios`).
* `docker rm <nombre_contenedor>`: Elimina un contenedor detenido.
* `docker build -t <nombre-imagen> .`: (Lo que us√°bamos al principio) Construye una imagen manualmente desde un `Dockerfile`.

---

## 6. Lecciones Aprendidas (Resoluci√≥n de Errores) üí°

Durante el proyecto, resolvimos problemas del mundo real:

* **Error de CORS (`Access-Control-Allow-Origin...`)**
    * **Causa:** El navegador (`localhost:3000`) intentaba llamar al `api_gateway` (`localhost:8000`). Al ser puertos diferentes, el navegador lo bloqueaba por seguridad.
    * **Soluci√≥n:** A√±adimos un "Middleware" en el `api_gateway` (Slim) que a√±ade los encabezados `Access-Control-Allow-Origin: 'http://localhost:3000'` a cada respuesta, d√°ndole permiso expl√≠cito al navegador.

* **Error de Login (`Credenciales incorrectas`)**
    * **Causa:** Hab√≠amos guardado la contrase√±a en la BD como texto plano (`123456`), pero el c√≥digo intentaba verificarla con `password_verify()`, que espera un **HASH**.
    * **Soluci√≥n:** Usamos el endpoint `/registro` (que usa `password_hash()`) para crear un usuario correctamente. La contrase√±a en la BD ahora se ve como `$2y$10$...`.

* **Error de Guzzle en `servicio_ventas` (`Connection refused`)**
    * **Causa:** El `servicio_ventas` (dentro de un contenedor) intentaba llamar a `http://localhost:8000/productos`.
    * **Soluci√≥n:** `localhost` dentro de un contenedor es *√©l mismo*. La direcci√≥n correcta para la comunicaci√≥n interna de Docker es el **nombre del servicio**: `http://productos/productos/...`.

* **Error de Docker Build (`mongodb.so: undefined symbol: SSL_...`)**
    * **Causa:** La extensi√≥n de PHP para MongoDB (`pecl install mongodb`) necesita las librer√≠as de SSL del sistema operativo. Nuestra "receta" (`Dockerfile`) intent√≥ instalar la extensi√≥n de PHP antes que las librer√≠as del sistema.
    * **Soluci√≥n:** Modificamos el `Dockerfile` del `servicio_productos` para que primero ejecutara `RUN apt-get install -y libssl-dev` y *luego* ejecutara `RUN pecl install mongodb...`.

* **Error de Vol√∫menes (`403 Forbidden`)**
    * **Causa:** Usamos `volumes:` para ver los cambios de c√≥digo en vivo. Esto cre√≥ un "portal" a los archivos de nuestra m√°quina, que eran propiedad del usuario `mariano3128`. El Apache *dentro* del contenedor (usuario `www-data`) no ten√≠a permisos para leerlos.
    * **Soluci√≥n:** Usamos el flag `:Z` en el `docker-compose.yml` (ej. `- ./frontend:/var/www/html:Z`). Esto le indica a Docker que ajuste las "etiquetas" de seguridad de SELinux para permitir que el contenedor lea los archivos del host.
```

```
# Gu√≠a del Proyecto (Parte 2): L√≥gica de Negocio Avanzada y Escalabilidad üöÄ

Esta segunda fase del proyecto lleva la arquitectura de microservicios b√°sica (construida en la Parte 1) a un nivel profesional, implementando patrones de dise√±o h√≠bridos, auditor√≠a centralizada, geolocalizaci√≥n y reportes visuales.

---

## 1. üß† Arquitectura H√≠brida y Patrones de Datos

Uno de los mayores desaf√≠os resueltos en esta etapa fue la gesti√≥n de datos distribuidos entre diferentes motores de base de datos.

### A. Persistencia Pol√≠glota (MySQL + MongoDB)
En lugar de usar una sola base de datos para todo, utilizamos la herramienta adecuada para cada trabajo:
* **MySQL (`servicio_ventas`, `servicio_usuarios`):** Para datos relacionales, transaccionales y cr√≠ticos (Ventas, Items de Venta, Usuarios, Asistencia). Garantiza integridad referencial y consistencia financiera.
* **MongoDB (`servicio_productos`):** Para el cat√°logo de productos. Permite flexibilidad (ej. agregar campos como "categor√≠a" sin migrar esquemas) y alta velocidad de lectura.

### B. "Application-Level Join" (El Pegamento PHP) üß©
Al separar las bases de datos, perdimos la capacidad de hacer `JOIN` en SQL entre Ventas y Productos. Implementamos el patr√≥n de **Composici√≥n de Datos en el Backend**:
1.  El `servicio_ventas` consulta MySQL para obtener los IDs y montos.
2.  El `servicio_ventas` llama internamente (v√≠a Guzzle) al `servicio_productos` para obtener el cat√°logo (IDs y Nombres).
3.  **PHP** combina ambos arrays en memoria antes de enviar la respuesta al Frontend.

---

## 2. üõ°Ô∏è Nuevo Microservicio: Auditor√≠a Centralizada

Creamos un cuarto servicio dedicado exclusivamente a la seguridad y trazabilidad.

* **Nombre:** `servicio_auditorias`
* **Base de Datos:** MySQL (`logs_auditoria`).
* **Funci√≥n:** Actuar como un "buz√≥n" donde todos los dem√°s servicios depositan registros de lo que sucede.
* **Patr√≥n de Implementaci√≥n:**
    * Usamos bloques `try...catch` en los servicios emisores (Ventas, Usuarios, Productos).
    * Si una operaci√≥n es exitosa, enviamos un log de tipo `_OK`.
    * Si ocurre una excepci√≥n, capturamos el error y enviamos un log `_ERROR` o `_FALLO`.
    * **Resiliencia:** La llamada a auditor√≠a est√° aislada; si el sistema de logs falla, la operaci√≥n principal (ej. la venta) **no** se detiene.

---

## 3. üìç Geolocalizaci√≥n y Mapas Interactivos

Mejoramos la UX (Experiencia de Usuario) del Administrador integrando mapas reales.

* **Tecnolog√≠as:** `Leaflet.js` (Mapas) + `OpenStreetMap` + `Leaflet-GeoSearch` (Buscador).
* **Flujo:**
    1.  El administrador busca una direcci√≥n (ej. "Av. Corrientes 123").
    2.  El servicio de geocodificaci√≥n (Nominatim) devuelve las coordenadas.
    3.  El sistema autocompleta los campos `latitud` y `longitud` en el formulario.
    4.  Estos datos se guardan en MySQL para futuras funcionalidades (ej. c√°lculo de distancias).

---

## 4. üìä Inteligencia de Negocios (BI) y Reportes

Transformamos datos crudos en informaci√≥n visual para la toma de decisiones.

* **Tecnolog√≠a Frontend:** `Chart.js` para gr√°ficos interactivos (Barras y Torta).
* **Reportes Implementados:**
    1.  **Top Productos (H√≠brido):** MySQL calcula los m√°s vendidos (SUM de cantidades), Mongo provee los nombres.
    2.  **Ventas por Sucursal (SQL):** Filtrado r√°pido por `sucursal_id`.
    3.  **Ventas por Categor√≠a (Complejo):** Agrupamos ventas en MySQL y las cruzamos con las categor√≠as din√°micas de Mongo.
    4.  **Control de Personal:** C√°lculo preciso de horas trabajadas (usando `TIMESTAMPDIFF` en minutos) y liquidaci√≥n de sueldos basada en tarifa por hora.

---

## 5. üõí Funcionalidades del Vendedor (Punto de Venta)

Se implement√≥ un flujo de trabajo completo para el empleado:

1.  **Ciclo de Asistencia:**
    * **Clock-in Autom√°tico:** Al hacer login.
    * **Clock-out Manual:** Bot√≥n dedicado que cierra el turno en la BD.
2.  **Gesti√≥n de Inventario:** Capacidad de crear productos y **categorizarlos** din√°micamente (usando `datalist` para sugerencias).
3.  **Carrito de Compras:** L√≥gica en JavaScript para acumular m√∫ltiples productos en memoria antes de enviar una √∫nica transacci√≥n at√≥mica al backend.

---

## 6. üîß Resoluci√≥n de Problemas T√©cnicos (Parte 2)

Desaf√≠os avanzados que resolvimos durante esta fase:

* **Error `Could not resolve host: auditorias`:**
    * **Causa:** El nombre del servicio en `docker-compose.yml` no coincid√≠a con la URL a la que Guzzle intentaba llamar.
    * **Soluci√≥n:** Estandarizamos los nombres (Docker DNS interno).
* **Error `Class GuzzleHttp\Client not found`:**
    * **Causa:** Agregamos la librer√≠a al `composer.json` pero el contenedor segu√≠a usando una versi√≥n vieja.
    * **Soluci√≥n:** Usamos `docker-compose up --build` para forzar la reinstalaci√≥n de dependencias.
* **Error `forEach is not a function` en Frontend:**
    * **Causa:** El backend devolv√≠a un objeto JSON de error (`{ "error": "..." }`) cuando el JS esperaba un Array (`[...]`).
    * **Soluci√≥n:** Agregamos validaci√≥n en el JS para detectar si la respuesta conten√≠a una propiedad `error` antes de intentar iterar.
* **Logs fallidos en "Crear Producto":**
    * **Causa:** El servicio de auditor√≠a rechazaba peticiones sin `usuario_id`, pero algunas acciones eran autom√°ticas.
    * **Soluci√≥n:** Flexibilizamos la tabla SQL (permitiendo `NULL`) y mejoramos el Frontend para enviar siempre el ID del usuario cuando est√° disponible.

---

## 7. Estado Final del Proyecto

El sistema ha evolucionado de un monolito simple a un **ERP (Sistema de Planificaci√≥n de Recursos Empresariales) basado en Microservicios**.

| Servicio | Base de Datos | Responsabilidad Principal |
| :--- | :--- | :--- |
| **Frontend** | - | Interfaz visual, Mapas, Gr√°ficos, L√≥gica de Carrito. |
| **Gateway** | - | Seguridad (JWT), Enrutamiento, RBAC (Roles). |
| **Usuarios** | MySQL | Auth, Empleados, Sucursales, Asistencia, Sueldos. |
| **Productos** | MongoDB | Cat√°logo, Precios, Stock, Categor√≠as. |
| **Ventas** | MySQL | Transacciones, Detalles de Venta, Reportes Financieros. |
| **Auditor√≠a** | MySQL | Logs centralizados de errores y actividades. |